using System.Collections;
using System.Collections.Generic;
using UnityEngine;



public class CarFollowController : MonoBehaviour
{

    // Retrieving all Car components from Unity
    [Header("Wheel colliders")]
    [SerializeField] WheelCollider FrontleftCollider;
    [SerializeField] WheelCollider FrontRightCollider;
    [SerializeField] WheelCollider BackleftCollider;
    [SerializeField] WheelCollider BackRightCollider;

    [Header("Wheel objects")]
    [SerializeField] Transform FrontLeftTransform;
    [SerializeField] Transform FrontRightTransform;
    [SerializeField] Transform BackLeftTransform;
    [SerializeField] Transform BackRightTransform;

    // Some adjustables to be able to configure the car from within Unity
    [Header("Engine attributes")]
    [SerializeField] float EnginePower;
    [SerializeField] float Brakepower;
    [SerializeField] float MaxSteerAngle;

    [Header("Follow settings")]
    [SerializeField] Transform FollowTransform;
    [SerializeField] float FollowDistance;


    private float CurrentEnginePower = 0f;
    private float CurrentBrakePower = 0f;
    private float CurrentSteerAngle = 0f;
    private Rigidbody rb;
    private bool LookingTowards = true;


    // Gets the distance between the car and the object it is supposed to follow
    float GetDistance()
    {
        float distance = Vector3.Distance(FollowTransform.position, transform.position);

        return distance;
    }

    // Gets the angle between the car and the FollowTransform
    float GetAngle()
    {
        Vector3 RelativePositionTarget = FollowTransform.position - transform.position;
        float angle = Vector3.Angle(transform.forward, RelativePositionTarget);

        return angle;

    }

    // Gets the relative angle between the car and the FollowTransform
    float GetRelativeAngle()
    {
        Vector3 targetDir = FollowTransform.position - transform.position;
        Vector3 forward = transform.forward;
        float angle = Vector3.SignedAngle(targetDir, forward, Vector3.up);

        return angle;
    }

    // Check if the FollowTransform is in front of the car
    float CheckIfInFront()
    {
        float InFront = 0f;

        Vector3 heading = FollowTransform.position - transform.position;
        InFront = Vector3.Dot(heading, transform.forward);

        return InFront;
    }

    // Start is called before the first frame update
    void Start()
    {
        rb = GetComponent<Rigidbody>();
        
    }


    //FixedUpdate is called once per physics update
    private void FixedUpdate()
    {

        
        // Getting the distance and angle between the car and the followed point
        
        float distance = GetDistance();
        float angle = GetAngle();
        float relativeAngle = GetRelativeAngle();
        float InFront = CheckIfInFront();
        

        // Checking if the car is Looking towards the FollowTransform

        if (rb.rotation == FollowTransform.GetComponent<Rigidbody>().rotation)
        {
            LookingTowards = true;
        }

        else
        {
            LookingTowards = false;
        }

        // Determining the CurrentEnginePower based on the distance and if the car is in front of behind of the FollowTransform
        if (InFront > 0f)
        {
            CurrentBrakePower = 0f;

            if (distance < FollowDistance+100)
            {
                //rb.velocity = rb.velocity.normalized * FollowTransform.GetComponent<Rigidbody>().velocity.magnitude;
                //CurrentEnginePower = 0f;
                if(distance < FollowDistance+100 && distance > FollowDistance+50)
                {
                    CurrentEnginePower = distance / 100 * EnginePower;
                }

                else if (distance < FollowDistance+50 && rb.velocity.magnitude < FollowTransform.GetComponent<Rigidbody>().velocity.magnitude)
                {
                    CurrentEnginePower = distance/50 * EnginePower;
                }

                else if (distance < FollowDistance+25 && rb.velocity.magnitude > FollowTransform.GetComponent<Rigidbody>().velocity.magnitude)
                {
                    CurrentBrakePower = Brakepower;
                }
            }


            else
            {
                CurrentEnginePower = EnginePower;
            }
        }

        else
        {
            CurrentEnginePower = 0f;
            CurrentBrakePower = Brakepower;
        }

        FrontleftCollider.motorTorque = CurrentEnginePower;
        FrontRightCollider.motorTorque = CurrentEnginePower;

        FrontleftCollider.brakeTorque = CurrentBrakePower;
        FrontRightCollider.brakeTorque = CurrentBrakePower;


        // Changing SteerAngle

        if (LookingTowards == false)
        {
            if (relativeAngle > 0)
            {
                if (angle > MaxSteerAngle)
                {
                    CurrentSteerAngle = -MaxSteerAngle;
                }

                else
                {
                    CurrentSteerAngle = -angle;
                }
            }

            else
            {
                if (angle > MaxSteerAngle)
                {
                    CurrentSteerAngle = MaxSteerAngle;
                }

                else
                {
                    CurrentSteerAngle = angle;
                }
            }
        }

        else CurrentSteerAngle = 0f;

        

        FrontleftCollider.steerAngle = CurrentSteerAngle;
        FrontRightCollider.steerAngle = CurrentSteerAngle;


        //making the wheel models turn and rotate

        void UpdateWheel(WheelCollider col, Transform trans)
        {
            Vector3 position;
            Quaternion rotation;
            col.GetWorldPose(out position, out rotation);

            trans.SetPositionAndRotation(position, rotation);
        }
        UpdateWheel(FrontleftCollider, FrontLeftTransform);
        UpdateWheel(FrontRightCollider, FrontRightTransform);
        UpdateWheel(BackleftCollider, BackLeftTransform);
        UpdateWheel(BackRightCollider, BackRightTransform);
    }
}
